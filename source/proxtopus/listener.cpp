#include "pch.h"

void listener::api(json_saver& s) const
{
	apiobj::api(s);
	s.field(ASTR("name"), name);
	s.obj(ASTR("handler"));
	hand->api(s);
	s.objclose();
}

void listener::build(lcoll& arr, loader &ldr, const str::astr& name, const asts& bb)
{
	str::astr t = bb.get_string(ASTR("type"), glb.emptys);
	if (t.empty())
	{
		ldr.exit_code = EXIT_FAIL_TYPE_UNDEFINED;
		LOG_E("{type} not defined for lisnener [%s]; type {proxtopus help listener} for more information", str::printable(name));
		return;
	}

	for (str::token<char, str::sep_onechar<char, '|'>> tkn(str::view(t)); tkn; tkn())
	{
		listener* l = nullptr;
		if (ASTR("tcp") == *tkn)
		{
			l = NEW tcp_listener(ldr, name, bb);
			if (ldr.exit_code != EXIT_OK)
			{
				delete l;
				return;
			}
		} else if (ASTR("udp") == *tkn)
		{
			l = NEW udp_listener(ldr, name, bb);
			if (ldr.exit_code != EXIT_OK)
			{
				delete l;
				return;
			}
		}
		if (l)
		{
			arr.emplace_back(l);
		}
		else
        {
			t = *tkn;
            LOG_E("unknown {type} [%s] for lisnener [%s]; type {proxtopus help listener} for more information", t.c_str(), str::printable(name));
            ldr.exit_code = EXIT_FAIL_TYPE_UNDEFINED;
			return;
		}
	}
}

listener::listener(loader& /*ldr*/, const str::astr& name, const asts& /*bb*/)
{
	this->name = name;
}

socket_listener::socket_listener(loader& ldr, const str::astr& name, const asts& bb, netkit::socket_type_e st) :listener(ldr, name, bb)
{
	const asts* hnd = bb.get(ASTR("handler"));
	if (nullptr == hnd)
	{
		ldr.exit_code = EXIT_FAIL_NOHANDLER;
		LOG_E("handler not defined for listener [%s]", str::printable(name));
		return;
	}

	handler* h = handler::build(ldr, this, *hnd, st);
	if (h == nullptr)
		return; // no warning message here due it generated by handler::build

	hand.reset(h);

	str::astr bs = bb.get_string(ASTR("bind"), glb.emptys);
	bind = netkit::ipap::parse(bs);

	if (bind.port == 0)
	{
		signed_t port = bb.get_int(ASTR("port"));
		if (0 == port)
		{
			ldr.exit_code = EXIT_FAIL_PORT_UNDEFINED;
			LOG_E("port not defined for listener [%s]", str::printable(name));
			hand.reset();
			return;
		}
		bind.port = (u16)port;

	}
}

socket_listener::socket_listener(const netkit::ipap& bind, handler* h): listener(h), bind(bind)
{
}

void socket_listener::acceptor()
{
	state.lock_write()().stage = ACCEPTOR_WORKS;

	accept_impl();

	state.lock_write()().stage = IDLE;

	spinlock::decrement(glb.numlisteners);
}

/*virtual*/ void socket_listener::api(json_saver& j) const
{
	listener::api(j);
	j.field(ASTR("bind"), bind.to_string(true));
	j.field(ASTR("idle"), state.lock_read()().stage == IDLE ? 1 : 0);
}

/*virtual*/ void socket_listener::open()
{
	auto ss = state.lock_write();
	if (ss().stage != IDLE)
		return;
	ss().stage = ACCEPTOR_START;
	ss.unlock();

	spinlock::increment(glb.numlisteners);

	std::thread th(&socket_listener::acceptor, this);
	th.detach();
}

/*virtual*/ void socket_listener::stop()
{
	if (state.lock_read()().stage == IDLE)
		return;

	state.lock_write()().need_stop = true;

	// holly stupid linux behaviour...
	// we have to make a fake connection to the listening socket so that the damn [accept] will deign to give control.
	// There is no such crap in Windows

	NIXONLY(kick_socket());

	close(false);

	while (state.lock_read()().stage != IDLE)
		spinlock::sleep(100);

	state.lock_write()().need_stop = false;
}



tcp_listener::tcp_listener(loader& ldr, const str::astr& name, const asts& bb) :socket_listener(ldr, name, bb, netkit::ST_TCP)
{
	if (!hand)
		return;

	if (!hand->compatible(netkit::ST_TCP))
	{
		ldr.exit_code = EXIT_FAIL_INCOMPATIBLE_HANDLER;
		LOG_E("handler %s is not compatible with listener [%s] (TCP not supported)", str::printable(hand->desc()), str::printable(name));
		return;
	}
}

/*virtual*/ void tcp_listener::api(json_saver& j) const
{
	socket_listener::api(j);
	j.field(ASTR("type"), ASTR("tcp"));
}

#ifdef _NIX
/*virtual*/ void tcp_listener::kick_socket()
{
    netkit::ipap cnct = netkit::ipap::localhost(bind.v4);
    if (!bind.is_wildcard())
        cnct = bind;
    else
        cnct.set_port(bind.port);

    SOCKET s = ::socket(cnct.v4 ? AF_INET : AF_INET6, SOCK_STREAM, IPPROTO_TCP);
    cnct.connect(s);
    closesocket(s);
}
#endif

void pipe_worker(handler* h, netkit::pipe* p)
{
	h->handle_pipe(p);
}

/*virtual*/ void tcp_listener::accept_impl()
{
	if (sock.listen(name, bind))
	{
#ifdef _DEBUG
        accept_tid = spinlock::tid_self();
#endif // _DEBUG

		LOG_N("listener {%s} has been started (bind: %s)", str::printable(name), bind.to_string(true).c_str());

		stats::tick_collector cl("tcp lst");

		for (; !state.lock_read()().need_stop;)
		{
			cl.collect();

			netkit::tcp_pipe* pipe = sock.tcp_accept(name);
			if (nullptr != pipe)
			{
                std::thread th(pipe_worker, hand.get(), pipe);
                th.detach();
			}
		}

		hand->stop();
	}

}


udp_listener::udp_listener(loader& ldr, const str::astr& name, const asts& bb) :socket_listener(ldr, name, bb, netkit::ST_UDP)
{
	if (ldr.exit_code != EXIT_OK)
		return;

	if (!hand->compatible(netkit::ST_UDP))
	{
		ldr.exit_code = EXIT_FAIL_INCOMPATIBLE_HANDLER;
		LOG_E("handler %s is not compatible with listener [%s] (UDP not supported)", str::printable(hand->desc()), str::printable(name));
		return;
	}
}

udp_listener::udp_listener(const netkit::ipap& bind, handler *h):socket_listener(bind, h)
{
}

/*virtual*/ void udp_listener::api(json_saver& j) const
{
    socket_listener::api(j);
    j.field(ASTR("type"), ASTR("udp"));
}


#ifdef _NIX
/*virtual*/ void udp_listener::kick_socket()
{
    netkit::ipap cnct = netkit::ipap::localhost(bind.v4);
    if (!bind.is_wildcard())
        cnct = bind;
    else
        cnct.set_port(bind.port);

    SOCKET s = ::socket(cnct.v4 ? AF_INET : AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
	u8 tmp = 0;
    cnct.sendto(s, std::span<const u8>(&tmp,1));
    closesocket(s);
}
#endif


/*virtual*/ void udp_listener::accept_impl()
{
	signed_t port = sock.listen_udp(name, bind);
	if (port > 0)
	{
#ifdef _DEBUG
		accept_tid = spinlock::tid_self();
#endif // _DEBUG

		hand->on_listen_port(port);

		if (name.empty())
        {
            LOG_N("udp listener has been started (bind: %s)", bind.to_string(port).c_str());
		}
		else
		{
            LOG_N("udp listener {%s} has been started (bind: %s)", str::printable(name), bind.to_string(port).c_str());
		}

		stats::tick_collector cl("udp lst");

		for (; !state.lock_read()().need_stop;)
		{
			cl.collect();

			netkit::udp_packet p(bind.v4);
			if (sock.recv(p))
            {
                if (glb.is_stop())
                    break;
                hand->udp_dispatch( sock, p );
            }
		}

		hand->stop();
	}

}

